# Implementation Roadmap: **vaam‑eat‑aio**

This roadmap breaks the platform build into clear, sequenced phases that match **ARCHITECTURE.md**. Every phase and sub‑phase has a one‑line description, and each task under it is atomic with its own one‑liner.

---

## Overview

Follow the schema‑driven, domain‑modular approach from `ARCHITECTURE.md` and `prisma/schema.zmodel`, moving top‑down to avoid context switches.

---

## **State Management Strategy** *(tRPC + TanStack Query + Zustand + localforage)*

> **Purpose:** Define clear boundaries between *server‑state* and *client‑only* state so that data is never duplicated and UX remains snappy—even offline.

| Concern                                                                   | Primary Tool                                             | Implementation Notes                                                                                                                                                                                                       |
| ------------------------------------------------------------------------- | -------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Server / remote data** (CRUD, caching, optimistic updates, realtime)    | **tRPC auto‑generated by ZenStack** + **TanStack Query** | Generated procedures are wrapped in `@trpc/react-query` hooks **under the `trpc.zen.<entity>` namespace** (e.g., `trpc.zen.product.list.useQuery`). No data from these hooks should ever be mirrored into any other store. |
| **Client‑only / ephemeral state** (cart, UI flags, filters, map viewport) | **Zustand** *(persisted via `localforage`)*              | One global store with domain‑specific slices. Persistence handled via `persist` middleware + `createJSONStorage(() => localForage)`.                                                                                       |

### Core Rules

1. **Single Source of Truth**
   * Remote data lives **only** in generated tRPC via TanStack Query’s cache.
   * UI/session data lives **only** in Zustand.
2. **Query Keys Driven by Store Values**
   Use Zustand selectors directly inside `trpc.zen.*.useQuery([...key])` so cache invalidation remains automatic.
3. **Invalidate, Don’t Copy**
   On every successful mutation, call `queryClient.invalidateQueries([...])` or use the ZenStack‑generated invalidation helpers instead of updating Zustand manually.
4. **Persistence Layer**
   Cart and other long‑lived client state is persisted to IndexedDB via `localforage` to survive hard refreshes and PWAs.
5. **Provider Order**
   Done in `@app/trpc/react.tsx` and imported in `src/app/layout.tsx`

---

## Mermaid Diagram – Phase Flow & Domain Dependencies

```mermaid
flowchart TD
    A[Foundational Setup]
    B[Authentication & Users]
    C[Vendors]
    D[Product Catalog]
    E[Cart & Checkout]
    F[Orders & Fulfillment]
    G[Coupons & Discounts]
    H[Search & Discovery]
    I[SEO & Metadata]
    A --> B --> C --> D --> E --> F --> G --> H --> I
```

---

## Phase 1 · Foundational Setup *(✓ completed)*

*Set up the core environment, toolchain, and initial schema baseline.*

### 1.1 Environment & Tooling
*Bootstrap linting, formatting, styling, containerization, and deployment tooling.*

* [x] **ESLint + Prettier + TS strict** — lock in linting, formatting, and strict typing across the codebase.
* [x] **Tailwind CSS + daisyUI install** — set up utility‑first styling with themed components.
* [x] **`@app` alias configured** — simplify deep imports via `tsconfig.json` and eslint resolver.
* [x] **Multi‑stage Docker & Compose** — define containers for web, Postgres, Redis, MinIO, and Mailpit.
* [x] **VEnv vars** — enable CI/CD and preview deploys on PRs.
* [x] **Global `showErrorToast` util** — standardise user‑facing error handling via `@app/utils/error-handler.ts`.
* [ ] **Install Zustand + localforage** — add `zustand`, `zustand/middleware`, and `localforage` deps; set up example persisted store.

### 1.2 Core Directory Skeleton
*Define base folders and naming rules to enforce code organization.*

* [x] **Scaffold App Router segments** — create `(auth)`, `(vendor)`, `(checkout)`, `(product)`, `(main)`, and `api` groups.
* [x] **Create base folders** — initialize `src/components`, `src/hooks`, `src/server`, `src/trpc`, and `prisma`.
* [ ] **Enforce naming conventions** — use PascalCase for component files and kebab-case for helpers and routes.

### 1.3 Database & Schema
*Establish initial data models, migrations, seeds, and local dependencies.*

* [x] **Define ZModel entities** — User, Account, Session, Vendor, Product, Cart, Order, and Coupon schemas.
* [x] **Install ZenStack plugins** — generate ACL, Prisma, and tRPC integration.
* [x] **Run initial `prisma migrate` & commit** — apply migrations and version SQL in Git.
* [x] **Seed local database** — add sample data for rapid UI development.
* [x] **Compose services** — spin up Postgres, Redis, MinIO, and Mailpit via `docker-compose.yml`.

---

## Phase 2 · Authentication & Users *(✓ completed)*

*Build user auth flows, schemas, routers, and UI.*

### 2.1 Models & ACLs
*Define auth data models and enforce access controls.*

* [x] **Finalize User/Account/Session schemas** — solidify authentication structures in ZModel.
* [x] **Write ZenStack ACL rules** — restrict personal data to respective users.

### 2.2 API Routers
*Create secure, type‑safe endpoints for auth operations.*

* [x] **Implement NextAuth handler** — support OAuth/email login with JWT in `src/app/api/auth/[...nextauth]/route.ts`.

### 2.3 UI
*Deliver authentication and profile management interfaces.*

* [x] **Build auth pages** — login, register, reset password, and verify email screens.
* [x] **Develop profile & settings pages** — allow users to view and update account info.

### 2.4 State & Validation
*Integrate form handling and client‑side caching.*

* [x] **Integrate Formik + Zod** — client‑side form handling and schema validation.
* [x] **Use generated tRPC** — cache and manage user and session state reactively.

---

## Phase 3 · Vendors

*Enable vendor onboarding, management, and dashboard capabilities.*

### 3.1 Models & ACLs *(✓)*
*Model vendor entities and permissions.*

* [x] **Add Vendor & VendorMembership schemas** — represent merchant accounts and roles.
* [x] **Author ZenStack ACL for vendors** — enforce admin‑only access to vendor resources.

### 3.2 UI *(✓)*
*Provide vendor dashboard and component library.*

* [ ] **Implement vendor dashboard UI** — product management, orders view, and analytics.
* [x] **Build vendor component library** — reusable elements in `src/components/vendor/`.

### 3.3 State & Access Control
*Manage client cache and test ACL enforcement.*

* [ ] **Cache vendor data with generated tRPC** — offline‑first UX for vendor pages.
* [ ] **Write ACL integration tests** — validate ZenStack rules on all vendor procedures.

---

## Phase 4 · Product Catalog

*Construct product and category schemas, endpoints, and UI.*

### 4.1 Models & Schema
*Define catalog entities and relationships.*

* [x] **Define Product, Category & Tag models** — schema relations and indexes in ZModel.
* [x] **Set up foreign keys** — Vendor↔Product and Product↔Category in Prisma.

### 4.2 UI
*Develop catalog browsing and landing interfaces.*

* [ ] **Build catalog pages** — grid views, filters, and product details.
* [x] **Home category section** — featured categories on the landing page.

### 4.3 State & Caching
*Implement client caching and server‑side acceleration.*

* [ ] **Use generated tRPC** — infinite scroll, pagination, and for product data.

---

## Phase 5 · Cart & Checkout

*Implement shopping cart flows, checkout logic, and UI.*

### 5.1 Models
*Define shopping basket schemas and relations.*

* [x] **Add Cart & CartItem schemas** — basket structure and attributes.
* [x] **Link User↔Cart & Cart↔Product** — enforce ownership and stock references.

### 5.2 UI
*Create interactive cart and checkout UIs.*

* [ ] **Create cart UI** — drawer, listing, and item controls in `src/components/cart/`.
* [ ] **Build checkout flow** — address form, payment step, and order confirmation.

### 5.3 State & Validation
*Manage reactive cart state and form validation.*

* [ ] **Persist cart with Zustand + localforage** — offline cart retrieval and multi‑tab sync.
* [ ] **Sync cart with generated tRPC** — query invalidate on checkout and stock updates.
* [ ] **Use Formik + Zod** — validate address and payment forms client‑side.

---

## Phase 6 · Orders & Fulfillment

*Build order placement, tracking, and vendor fulfillment flows.*

### 6.1 Models
*Specify order schemas and status lifecycle.*

* [x] **Define Order, OrderItem & Fulfillment models** — capture line items and shipments.
* [x] **Add status enums** — PENDING, CONFIRMED, IN\_TRANSIT, DELIVERED, CANCELED.

### 6.2 UI
*Design order views for users and vendors.*

* [ ] **Build user orders pages** — list past and active orders.
* [ ] **Vendor order management** — vendor‑side lists and detail views.

### 6.3 State & Optimistic UI
*Enable responsive status updates.*

* [ ] **Use TanStack Query** — subscribe/poll for updates and cache state.
* [ ] **Enable optimistic updates** — immediate feedback on status changes.
* [ ] **Use zustand** — persist user's orders and vendors (immutable).

---

## Phase 7 · Coupons & Discounts

*Add promotional code support to cart and checkout.*

### 7.1 Models
*Model promo code entities and rules.*

* [ ] **Define Coupon & DiscountRule schemas** — represent promo and conditional logic.

### 7.2 UI
*Provide coupon input and feedback.*

* [ ] **Add coupon UI** — input fields and validation messages in cart/checkout.

### 7.3 State & Validation
*Integrate coupon logic into cart pricing.*

* [ ] **Recalculate totals on apply** — update cart state with discounts via TanStack Query.
* [ ] **Use zustand** — persist user's coupons.

---

## Phase 8 · Search & Discovery

*Implement search capabilities for products and vendors.*

### 8.1 UI
*Design search interface and result layouts.*

* [ ] **Use MapLibre page** —  map-first inputs.
* [ ] **Search page in modal** — on top of the map, filters, and result grid.

### 8.2 State & Caching
*Optimize client UX and server caching.*

* [ ] **Use TanStack Query** — debounce, cache, and infinite scroll.
* [ ] **Use protomaps** — download maps, offline use, conditional – depends on the user.

---

## Phase 9 · SEO & Metadata

*Ensure SEO best practices and structured data are in place.*

### 9.1 Dynamic Metadata
*Generate page meta and social tags.*

* [ ] **Generate metadata** — titles, descriptions, and OpenGraph via `generateMetadata`.
* [ ] **Implement sitemap route** — dynamic `sitemap.xml` in `src/app/api/sitemaps/route.ts`.

### 9.2 Structured Data
*Add rich result markup for search engines.*

* [ ] **Add JSON‑LD** — embed product and vendor schemas for SERP enhancements.

---

## Cross‑Cutting Obligations (continuous)

*Apply quality, performance, and security standards across all phases.*

| Area            | Checklist                                                                                            |
| --------------- | ---------------------------------------------------------------------------------------------------- |
| **Error UX**    | Always call `showErrorToast` for any user‑facing error flows.                                        |
| **Testing**     | Unit → **vitest** + in‑memory SQLite; Component → Testing‑Library + MSW; e2e → Playwright later.     |
| **Access**      | Enforce ZenStack ACLs on all tRPC procedures at field‑ and role‑level.                               |
| **Performance** | Leverage Redis caching, `revalidatePath()`, lazy loading, and weekly bundle analysis.                |
| **State**       | Follow the **State Management Strategy** table—no cross‑duplication, cart persisted via localforage. |
| **DevOps**      | Harden Docker images, scan CVEs, enforce 90%+ test coverage, blue‑green deploy, multi‑region HA.     |

---
